Design notes: 
    - despite previously promising to use adult languages for multithreaded programming, we decided to use a child language (Python) due to ease of controlling mFi smart powerstrips using manufacturer's distribution of python code.

TO DO:
    _ [DUE: 04/29] build hardware 
        _ remove mirror from cabinet
        _ replace mirror in cabinet w/ one-way mirror 
        _ embed pi with webcam behind mirror
        _ embed 12x+ lightbulbs in mirror 
        _ set static IPs for mFi devices
    _ [DUE: 04/30] webcam pulse capture
    _ [DUE: 04/30] leader election via bully
        _ 13 threads, 1 for pi, 12 for lightbulbs
        _ assign UUIDS for 12 lightbulbs
        _ on startup, run bully leader election
    _ [DUE: 04/30] 
        _ parallel control of 2x mFi devices 
    _ [DUE: 05/01] Presentation draft
        _ slides
        _ demo working
    _ [DUE: 05/02] Presentation
    _ [DUE: 05/07] Gossip algorithm! 
    _ [DUE: 05/09] Whole project, including documentation

04/25
    - Physical hardware design finalized 
        - Embedding bulbs around a medicine cabinet
        - Using a webcam behind one-way glass to determine heartbeat of person before mirror
        - Pi, ethernet switch, 3x ethernet cables, 12x bulbs, 2x smart power strips, 1x nonsmart power strip embedded in cabinet
    - Bully! 
        - on startup, each bulb creates a list of all other bulb uuids 
            - if all 12 bulbs responded, max uuid bulb is leader
            - otherwise, wait up to 20 seconds. max uuid of the bulb responses is leader 
        - going forward, any bulb can query the current leader. If the leader doesn't respond within <x> seconds, bulb a declares an election
            - bulb a sends election message to all bulbs with higher uuid 
                - if no responses, bulb a becomes leader! 
                    - sends message to all bulbs with lower uuid to declare itself leader
                - if response, other bulb declares election. 

04/26   
    Today's goals: 
         any process can initiate an election
        - random timeout per socket, since we want to avoid having all bulbs initiate election at the same time

    Today's problems: 
        unable to kill a nonresponsive thread

    We want to avoid creating a connected graph for communication. 
        - We give the selected leader a "leader socket"
        - And each follower a "follower socket"
        - Any follower can query the leader. Given no response, the follower initiates an election. 
            - Design question: do we initialize sockets between the current process and the processes with higher ids?
            - or do we fall back on address manipulation

04/27
    Software side: 
        - After conversation with Waldo discussing modeling of virtual machines, we switched from using threads to using processes. 
        - While conversion was largely straightforward, we ran into an issue where we were creating local copies of memory which we intended to be  shared. We then decided to use the python Multiprocessing queue

    Hardware side: 
        - Installed picamera, got a demo running (camera_test.py)
        - Using paramiko, able to SSH directly to the power strips from Python 
        - Mirror and cabinet arrived! 

04/28
    - Dealing with a bug where each process has their own queue where we expect memory to be shared. Address of this queue is the same between processes?
        - Yay! Resolved! 
            - Had to switch queue type from Queue.Queue to multiprocessing.queues.Queue for process safety

    - Assign each bulb a "timeout" (random integer) which is the frequency with which they check that the leader is still alive