03/05, 9:05pm, Serena. 
    - Really not all that sure what I'm doing.
    - Planning to go after an OO-looking architecture, so a clock will be an object. 
    - OK, not sure what type of communication I want between these clocks. How about a socket between each pair of models? Initialized after the models... (Spent some time looking at other solutions like ZMQ, can't find anything perfect) Resolution: one socket per clock, and all other clocks can send messages to that. 
        - One port per socket, which is questionable. 

03/06, 1:30pm, Serena
    - Start a thread per clock. Keep all class variables as well as a dictionary of all sockets which all clocks can access. 
        - Back to the question of the intereference of the GIL?
    - Startup code in clock.__init__(...), logical clock responses to go in clock.run(...)
    - Not sure how to determine the number of messages waiting for processing on a socket... 
    - Not sure how to get remaining time until timeout on a socket. 

03/06, 5pm, Serena  
    - So we want to use the socket's timeout to indicate that we are able to run another instruction. How does one do this without constantly using exception-catching, which seems like bad style? 

3/07, 8pm, Michelle & Serena
    - We decided to have a clock object which contains two sockets, a client socket and a server socket. Each clock object has its own thread.
    - The server socket is contantly listening and accepting connections, but times out based on the ticks per minute of its internal clock. 
    - This timeout indicates when an action can be performed for that particular clock, so when it happens, a new thread is started to perform the appropriate action.
    - This new thread picks a random number to determine which action to perform (per the specification).
    - The client socket is used to perform these actions. It connects to the other server sockets when sending information (so that the server socket can continue accepting connections). 
    - Current issue:
        - After running a simple test to continuously send and accept messages (based on the clock times, but without actually updating clocks), we get a bad file descriptor error after a few iterations.
            - We initially thought this was caused by the server socket being closed for a short period of time, but further tests to retry to connect seem to indicate that something else is the problem. 